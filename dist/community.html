<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <meta name="description" content="">
        <meta name="author" content="">

        <title>Community</title>

        <!-- CSS FILES -->      
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/icons-webfont@latest/tabler-icons.min.css">
        <link href="assets/css/bootstrap.min.css" rel="stylesheet">
        <link href="assets/css/bootstrap-icons.css" rel="stylesheet">
        <link href="assets/css/apexcharts.css" rel="stylesheet">
        <link href="assets/css/tooplate-mini-finance.css" rel="stylesheet">
    </head>
    
    <body>
        <header class="navbar sticky-top flex-md-nowrap">          
            <div class="col-md-3 col-lg-3 me-0 px-3 fs-6">
                <img class = "logo-image" src="assets/imgs/logo-4.png" alt="" >
                <a class="logo align-items-center" href="index2.html"><b>Knotulus</b></a>          
            </div>

                <button class="navbar-toggler position-absolute d-md-none collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#sidebarMenu" aria-controls="sidebarMenu" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!--Search Bar-->
                 <form id="header-search-form" action="#" class="custom-form header-form ms-lg-0 ms-md-0 me-lg-auto me-md-auto order-0 order-lg-0 order-md-0" method="get" autocomplete="off">
                     <div class="form-control">
                        <label for="search-term"><i class="ti ti-search"></i></label>                  
                        <input class="search-bar" id="search-input" name="q" type="search" placeholder="Search Knots..." aria-label="Search" autocomplete="off"             
                               autocomplete="nope" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="search">             
                     </div>                             
                 </form>

            <div class="navbar-nav me-lg-2">
                <div class="nav-item text-nowrap d-flex align-items-center">
                    <div class="dropdown ps-3 ">
                        <a class="nav-link dropdown-toggle text-center" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false" id="navbarLightDropdownMenuLink">
                            <i class="ti ti-bell-filled" style="font-size: 2em;"></i>
                            <span class="bell-dot" aria-label="Unread notifications" title="Unread notifications"></span>
                        </a>

                        <ul class="dropdown-menu dropdown-menu-lg-end notifications-block-wrap shadow" aria-labelledby="navbarLightDropdownMenuLink">
                            <small>Notifications</small>

                            <li class="notifications-block border-bottom pb-2 mb-2">
                                <a class="dropdown-item d-flex  align-items-center" href="#">
                                    <div class="notifications-icon-wrap bg-success">
                                        <i class="notifications-icon bi-check-circle-fill"></i>
                                    </div>

                                    <div>
                                        <span>Your account has been created successfuly.</span>

                                        <p>12 days ago</p>
                                    </div>
                                </a>
                            </li>

                            <li class="notifications-block border-bottom pb-2 mb-2">
                                <a class="dropdown-item d-flex align-items-center" href="#">
                                    <div class="notifications-icon-wrap bg-info">
                                        <i class="notifications-icon bi-folder"></i>
                                    </div>

                                    <div>
                                        <span>Please check. We have sent a Daily report.</span>

                                        <p>10 days ago</p>
                                    </div>
                                </a>
                            </li>

                            <li class="notifications-block">
                                <a class="dropdown-item d-flex align-items-center" href="#">
                                    <div class="notifications-icon-wrap bg-danger">
                                        <i class="notifications-icon bi-question-circle"></i>
                                    </div>

                                    <div>
                                        <span>Account verification failed.</span>

                                        <p>1 hour ago</p>
                                    </div>
                                </a>
                            </li>
                        </ul>
                    </div>

                    <!--<div class="dropdown ps-1">
                        <a class="nav-link dropdown-toggle text-center" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="bi-three-dots-vertical"></i>
                        </a>

                        <div class="dropdown-menu dropdown-menu-social bg-white shadow">
                            <div class="container">
                                <div class="row">
                                    <div class="col-lg-4 col-md-4 col-4">
                                        <a class="dropdown-item text-center" href="#">
                                            <img src="images/social/search.png" class="profile-image img-fluid" alt="">
                                            <span class="d-block">Google</span>
                                        </a>
                                    </div>

                                    <div class="col-lg-4 col-md-4 col-4">
                                        <a class="dropdown-item text-center" href="#">
                                            <img src="images/social/spotify.png" class="profile-image img-fluid" alt="">
                                            <span class="d-block">Spotify</span>
                                        </a>
                                    </div>

                                    <div class="col-lg-4 col-md-4 col-4">
                                        <a class="dropdown-item text-center" href="#">
                                            <img src="images/social/telegram.png" class="profile-image img-fluid" alt="">
                                            <span class="d-block">Telegram</span>
                                        </a>
                                    </div>

                                    <div class="col-lg-4 col-md-4 col-4">
                                        <a class="dropdown-item text-center" href="#">
                                            <img src="images/social/snapchat.png" class="profile-image img-fluid" alt="">
                                            <span class="d-block">Snapchat</span>
                                        </a>
                                    </div>

                                    <div class="col-lg-4 col-md-4 col-4">
                                        <a class="dropdown-item text-center" href="#">
                                            <img src="images/social/tiktok.png" class="profile-image img-fluid" alt="">
                                            <span class="d-block">Tiktok</span>
                                        </a>
                                    </div>

                                    <div class="col-lg-4 col-md-4 col-4">
                                        <a class="dropdown-item text-center" href="#">
                                            <img src="images/social/youtube.png" class="profile-image img-fluid" alt="">
                                            <span class="d-block">Youtube</span>
                                        </a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>-->
                    
                    <div class="dropdown px-4">
                        <a class="nav-link dropdown-toggle d-flex align-items-center" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                            <!-- Colored initials avatar (kept as a div so we can style/update via JS) -->
                            <div id="header-avatar" class="header-avatar profile-img" role="img" aria-label="Profile avatar">U</div>
                        </a>
                        <ul class="dropdown-menu shadow">
                            <li>
                                <div class="dropdown-menu-profile-thumb d-flex align-items-center">
                                    <!-- Dropdown avatar shown beside name/email -->
                                    <div id="header-dropdown-avatar" class="header-dropdown-avatar profile-img me-3" role="img" aria-label="Profile avatar small">U</div>

                                    <div class="d-flex flex-column">
                                        <!-- IDs added so script can update dropdown when profile is changed -->
                                        <b id="header-small-name">Thomas</b>
                                        <small>
                                            <a id="header-small-email" href="mailto:thomas@site.com">thomas@site.com</a>
                                        </small>
                                    </div>
                                </div>
                            </li>

                            <li>
                                <a class="dropdown-item" href="profile.html">
                                    <i class="ti ti-user"></i>
                                    Profile
                                </a>
                            </li>

                            <li>
                                <a class="dropdown-item" href="setting.html">
                                    <i class="ti ti-settings"></i>
                                    Settings
                                </a>
                            </li>

                            <li>
                                <a class="dropdown-item" href="help-center.html">
                                    <i class="ti ti-help"></i>
                                    Help
                                </a>
                            </li>

                            <li class="border-top mt-3 pt-2">
                                <a class="dropdown-item" href="index.html">
                                    <i class="ti ti-logout"></i>
                                    Logout
                                </a>
                            </li>
                        </ul>                    
                    </div>
                </div>
            </div>
        </header>
        <br>
        <div class="container-fluid">
            <div class="row">
                <nav id="sidebarMenu" class="col-md-3 col-lg-3 d-md-block sidebar collapse">
                    <div class="position-sticky py-2 px-3 sidebar-sticky">
                        <ul class="nav flex-column h-100">
                            <br>
                            <div class="categories-title">&nbsp;&nbsp;Home</div>
                            <li class="nav-item"><a class="nav-link" href="index2.html"><i class="ti ti-layout-dashboard"></i> Dashboard</a></li>
                            <li class="nav-item"><a class="nav-link" href="leaderboard.html"><i class="ti ti-chart-bar"></i> Leaderboard</a></li>
                            <li class="nav-item"><a class="nav-link" href="quests.html"><i class="ti ti-book"></i> Quests</a></li>
                            <li class="nav-item"><a class="nav-link" href="premium.html"><i class="ti ti-rosette"></i> Premium</a></li>

                            <br>
                            <div class="categories-title">&nbsp;&nbsp;Discovery</div>

                            <br>
                            <div class="categories-title">&nbsp;&nbsp;Support</div>
                            <li class="nav-item"><a class="nav-link" href="community.html"><i class="ti ti-users"></i> Community</a></li>
                            <li class="nav-item"><a class="nav-link" href="setting.html"><i class="ti ti-settings"></i> Settings</a></li>
                            <li class="nav-item"><a class="nav-link" href="help-center.html"><i class="ti ti-help"></i> Help Center</a></li>

                            <br>
                            <li class="nav-item-tools border-top mt-auto pt-2" >
                                <!--Search Bar-->
                                <form id="sidebar-search-form" class="custom-form header-form ms-lg-0 ms-md-0 me-lg-auto me-md-auto order-0 order-lg-0 order-md-0" action="#" method="get" role="form">
                                    <div class="form-control">
                                        <label for="search-term"><i class="ti ti-search"></i></label> 
                                        <input class="search-bar" id="sidebar-search-input" name="search" type="text" placeholder="Search Knots..." aria-label="Search" autocomplete="off"
                                            autocomplete="nope" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="search">
                                    </div>
                                </form>  
    
                                <br>                                
                                <a class="nav-link-button" href="#">
                                    <label class="switch">
                                        <input id="input" type="checkbox" checked="darkTheme" />
                                        <span class="slider-round">
                                            <div class="star star_1"></div>
                                            <div class="star star_2"></div>
                                            <div class="star star_3"></div>
                                            <svg viewBox="0 0 16 16" class="cloud_1 cloud">
                                                <path
                                              transform="matrix(.77976 0 0 .78395-299.99-418.63)"
                                              fill="#fff"
                                              d="m391.84 540.91c-.421-.329-.949-.524-1.523-.524-1.351 0-2.451 1.084-2.485 2.435-1.395.526-2.388 1.88-2.388 3.466 0 1.874 1.385 3.423 3.182 3.667v.034h12.73v-.006c1.775-.104 3.182-1.584 3.182-3.395 0-1.747-1.309-3.186-2.994-3.379.007-.106.011-.214.011-.322 0-2.707-2.271-4.901-5.072-4.901-2.073 0-3.856 1.202-4.643 2.925"
                                                ></path>
                                            </svg>
                                        </span>
                                    </label>
                                </a>
                                <br>

                                <a class="nav-link-button" href="#">     
                                    <button class="nav-link-toggle-translate" id="theme-toggle">
                                        <i class="ti ti-language" style="font-size: 1.5em;"></i>
                                    </button>                                                                   
                                </a>

                                <a class="nav-link dropdown-toggle text-center" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false" id="sidebarBellTrigger">
                                    <i class="ti ti-bell-filled" style="font-size: 2em;"></i>
                                </a>
                                
                                <a class="nav-link-button" href="#">       
                                    <button class="nav-link-toggle-dark-theme" id="theme-toggle" disabled>
                                        <!--<i class="ti ti-moon" style="font-size: 1.5em;"></i>-->
                                    </button>                            
                                </a>
                            </li> 
                            <br><br>               
                        </ul>
                    </div>
                </nav>

                <main class="main-wrapper col-md-9 ms-sm-auto pb-4 col-lg-9 px-md-4 border-start border-top border-right border-bottom border-end">
                    <div class="row my-4">
                        <div class="title-group mb-3">
                            <h1 class="h7 mb-0">Community</h1>
                            <!--<small class="text-muted">Hello Thomas, welcome back!</small>-->
                        </div>

                        <!--<div class="col-lg-7 col-12">
                            <div class="custom-block-badges">
                                <div id="popup-container"></div>
                            </div>
                        </div>-->

                        <div class="col-lg-7 col-12">
                            <div class="custom-block-badges">
                                <div class="card-message">
                                    <div class="bar"></div>
                                    <div class="card_form"></div>
                                    <div class="card_data">
                                      <div class="data">
                                        <div class="text">
                                          <label class="text_m">Main Title</label>
                                          <div class="cube text_s">
                                            <label class="side front">Access the list (Topic)</label>
                                            <label class="side top">Username-id</label>
                                          </div>
                                          <label class="text_d"
                                            >Lorem ipsum dolor sit amet, consectetur adipiscing elit. Unum nescio,
                                            quo modo possit, si luxuriosus sit, finitas cupiditates habere.
                                          </label>
                                        </div>
                                      </div>
                                      <span title="Acceder a la lista (Temas)">Access</span>
                                    </div>
                                </div>
                            </div>

                            <div class="custom-block-badges expandable scrollable">
                                <button class="expand-toggle" aria-label="Expand block" title="Expand">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                                        <rect x="0" y="0" width="24" height="24" rx="4" fill="transparent" />
                                        <path d="M6 18 L18 6" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
                                        <path d="M14 6 L18 6 L18 10" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
                                        <path d="M18 18 L6 6" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
                                        <path d="M6 14 L6 18 L10 18" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                                <h5 class="mb-4"></h5> 
                                <div id="chat-container">
                                    <!-- chat messages will be appended here by the chat animation script -->
                                </div>
                                <!-- Input bar for sending chat messages -->
                                <div class="container-items">
                                <!-- Bot accounts: click to spawn bot with that name and color. Modifier click (Ctrl/Shift/Meta) sets your profile color. -->
                                <button class="item-color bot-account" data-bot-name="James" title="James" style="--color: #e11d48" aria-color="James">J</button>
                                <button class="item-color bot-account" data-bot-name="Ava" title="Ava" style="--color: #f472b6" aria-color="Ava">A</button>
                                <button class="item-color bot-account" data-bot-name="Noah" title="Noah" style="--color: #fb923c" aria-color="Noah">N</button>
                                <button class="item-color bot-account" data-bot-name="Emma" title="Emma" style="--color: #facc15" aria-color="Emma">E</button>
                                <button class="item-color bot-account" data-bot-name="Olivia" title="Olivia" style="--color: #84cc16" aria-color="Olivia">O</button>
                                <button class="item-color bot-account" data-bot-name="Mason" title="Mason" style="--color: #10b981" aria-color="Mason">M</button>
                                <button class="item-color bot-account" data-bot-name="Sophia" title="Sophia" style="--color: #0ea5e9" aria-color="Sophia">S</button>
                                <button class="item-color bot-account" data-bot-name="Lucas" title="Lucas" style="--color: #3b82f6" aria-color="Lucas">L</button>
                                <button class="item-color bot-account" data-bot-name="Aria" title="Aria" style="--color: #8b5cf6" aria-color="Aria">A</button>
                                <button class="item-color bot-account" data-bot-name="Liam" title="Liam" style="--color: #a78bfa" aria-color="Liam">L</button>
                                </div>

                                <div id="chat-input-area" class="mt-3 d-flex align-items-center" style="gap:8px;">
                                    <button id="chat-add-file" class="btn btn-dark" title="Add user" aria-pressed="false" style="width:42px;height:42px;padding:0;border-radius:8px;">+</button>
                                    <div class="chat-input-wrap" style="position:relative;flex:1;min-width:0;">
                                        <input id="chat-input-field" type="text" class="form-control" placeholder="Type a message..." aria-label="Chat message" style="width:100%;" />
                                        <div id="chat-mention-preview" class="mention-preview" hidden aria-hidden="true"></div>
                                    </div>
                                    <button id="chat-send-btn" class="btn btn-dark" title="Send" style="width:42px;height:42px;padding:0;border-radius:21px;">
                                        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
                                            <path fill="#fff" d="M9 6 L17 12 L9 18 Z" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div><br><br>
                        
                        <div class="col-lg-5 col-12">
                            <div class="custom-block-badges">
                                <div class="meeting-card">
                                <div class="header-meeting">
                                    <div class="title">Upcoming<br />Events</div>
                                    <div class="date-selector" id="month-selector">
                                    <span>September</span>
                                    <svg
                                        xmlns="http://www.w3.org/2000/svg"
                                        width="18"
                                        height="18"
                                        fill="currentColor"
                                        viewBox="0 0 16 16"
                                    >
                                        <path
                                        fill-rule="evenodd"
                                        d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"
                                        ></path>
                                    </svg>
                                    </div>
                                </div>

                                <div class="calls-info">
                                    <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="20"
                                    height="20"
                                    fill="currentColor"
                                    viewBox="0 0 16 16"
                                    >
                                    <path
                                        d="M3.654 1.328a.678.678 0 0 0-1.015-.063L1.605 2.3c-.483.484-.661 1.169-.45 1.77a17.568 17.568 0 0 0 4.168 6.608 17.569 17.569 0 0 0 6.608 4.168c.601.211 1.286.033 1.77-.45l1.034-1.034a.678.678 0 0 0-.063-1.015l-2.307-1.794a.678.678 0 0 0-.58-.122l-2.19.547a1.745 1.745 0 0 1-1.657-.459L5.482 8.062a1.745 1.745 0 0 1-.46-1.657l.548-2.19a.678.678 0 0 0-.122-.58L3.654 1.328zM1.884.511a1.745 1.745 0 0 1 2.612.163L6.29 2.98c.329.423.445.974.315 1.494l-.547 2.19a.678.678 0 0 0 .178.643l2.457 2.457a.678.678 0 0 0 .644.178l2.189-.547a1.745 1.745 0 0 1 1.494.315l2.306 1.794c.829.645.905 1.87.163 2.611l-1.034 1.034c-.74.74-1.846 1.065-2.877.702a18.634 18.634 0 0 1-7.01-4.42 18.634 18.634 0 0 1-4.42-7.009c-.362-1.03-.037-2.137.703-2.877L1.885.511z"
                                    ></path>
                                    </svg>
                                    <span>3 calls • Thu, 11</span>
                                </div>

                                <div class="date-nav-and-indicators">
                                    <div class="date-nav-container">
                                    <div class="day-item">
                                        <div class="day-number">8</div>
                                        <div class="day-name">Mon</div>
                                    </div>
                                    <div class="day-item">
                                        <div class="day-number">9</div>
                                        <div class="day-name">Tue</div>
                                    </div>
                                    <div class="day-item">
                                        <div class="day-number">10</div>
                                        <div class="day-name">Wed</div>
                                    </div>
                                    <div class="day-item day-active">
                                        <div class="day-number">11</div>
                                        <div class="day-name">Thu</div>
                                    </div>
                                    <div class="day-item">
                                        <div class="day-number">12</div>
                                        <div class="day-name">Fri</div>
                                    </div>
                                    <div class="day-item">
                                        <div class="day-number">13</div>
                                        <div class="day-name">Sat</div>
                                    </div>
                                    </div>

                                    <div class="indicator-container">
                                    <div class="indicator-line"></div>
                                    <div class="indicator-dot"></div>
                                    <div class="indicator-dot"></div>
                                    <div class="indicator-dot"></div>
                                    <div class="indicator-dot indicator-active"></div>
                                    <div class="indicator-dot"></div>
                                    <div class="indicator-dot"></div>
                                    </div>
                                </div>
                                </div>
                            </div>
                        </div>

                        <footer class="site-footer">
                        <div class="container">
                            <div class="row">
                                
                                <!--<div class="col-lg-12 col-12">
                                    <p class="copyright-text">Copyright © Mini Finance 2048 
                                    - Design: <a rel="sponsored" href="https://www.tooplate.com" target="_blank">Tooplate</a></p>
                                </div>-->

                            </div>
                        </div>
                    </footer>
                </main>

            </div>
        </div>

        <!-- JAVASCRIPT FILES -->
        <script src="assets/js/jquery.min.js"></script>
        <script src="assets/js/bootstrap.bundle.min.js"></script>
        <script src="assets/js/apexcharts.min.js"></script>
        <script src="assets/js/custom.js"></script>
        <script src="assets/js/notifications.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@tabler/icons@latest/icons-react/dist/index.umd.min.js"></script>

        <script type="text/javascript"> //dark mode toggle
            const themeToggleBtn = document.getElementById('theme-toggle');
            const body = document.body;
            const localStorageKey = 'dark-mode';

            // Function to set the theme
            function setTheme(isDarkMode) {
                if (isDarkMode) {
                    body.classList.add('dark-mode');
                    localStorage.setItem(localStorageKey, 'true');
                } else {
                    body.classList.remove('dark-mode');
                    localStorage.removeItem(localStorageKey);
                }
            }

            // Check for saved user preference on page load
            if (localStorage.getItem(localStorageKey) === 'true') {
                setTheme(true);
            }

            // Add event listener to the toggle button
            themeToggleBtn.addEventListener('click', () => {
                // Toggle the theme state
                setTheme(!body.classList.contains('dark-mode'));
            });

        </script>

        <script> //input trigger dark mode button
            // Input toggle -> dark mode control (robust, runs after DOM ready)
            document.addEventListener('DOMContentLoaded', () => {
                const checkbox = document.getElementById('input');
                const themeBtn = document.getElementById('theme-toggle');
                const bodyEl = document.body;
                const LS_KEY = 'dark-mode';
    
                // Helper: toggle theme and persist
                function applyTheme(enable) {
                    if (enable) {
                        bodyEl.classList.add('dark-mode');
                        localStorage.setItem(LS_KEY, 'true');
                    } else {
                        bodyEl.classList.remove('dark-mode');
                        localStorage.removeItem(LS_KEY);
                    }
                }
    
                // Initialize state from localStorage or body class
                const saved = localStorage.getItem(LS_KEY) === 'true';
                const initial = saved || bodyEl.classList.contains('dark-mode');
                applyTheme(initial);
                if (checkbox) checkbox.checked = !!initial;
    
                // Keep checkbox -> theme consistent
                if (checkbox) {
                    checkbox.addEventListener('change', () => {
                        const enable = checkbox.checked;
                        applyTheme(enable);
    
                        // Optionally simulate theme button click to keep UI in sync
                        if (themeBtn) {
                            try { themeBtn.disabled = false; themeBtn.click(); } catch (e) { /* ignore */ }
                        }
                    }, { passive: true });
                }
    
                // Ensure theme button still works and keeps checkbox synced
                if (themeBtn) {
                    themeBtn.addEventListener('click', () => {
                        const isDark = bodyEl.classList.contains('dark-mode');
                        applyTheme(!isDark);
                        if (checkbox) checkbox.checked = !isDark;
                    });
                }

                // Mention preview: show matching bot color & name when typing @Name
                try {
                    const mentionPreview = document.getElementById('chat-mention-preview');
                    const inputEl = document.getElementById('chat-input-field');
                    function hideMention() {
                        if (!mentionPreview) return;
                        mentionPreview.hidden = true;
                        mentionPreview.setAttribute('aria-hidden', 'true');
                        mentionPreview.innerHTML = '';
                    }
                    function updateMention() {
                        if (!mentionPreview || !inputEl) return;
                        const val = (inputEl.value || '');
                        const matches = Array.from(val.matchAll(/@([A-Za-z0-9_\-]+)/g));
                        if (!matches.length) return hideMention();
                        const last = matches[matches.length - 1][1];
                        const registry = window.BOT_REGISTRY || {};
                        let matched = null;
                        for (const k in registry) {
                            if (Object.prototype.hasOwnProperty.call(registry, k) && k.toLowerCase() === last.toLowerCase()) {
                                matched = k;
                                break;
                            }
                        }
                        if (!matched) return hideMention();
                        const col = registry[matched] || '#999';
                        mentionPreview.innerHTML = `<span class="mention-swatch" aria-hidden="true" style="background:${col}"></span><span class="mention-label">${matched}</span>`;
                        mentionPreview.hidden = false;
                        mentionPreview.setAttribute('aria-hidden', 'false');
                    }

                    if (inputEl) {
                        inputEl.addEventListener('input', updateMention, { passive: true });
                        inputEl.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') hideMention();
                        });
                    }

                    // hide preview on send or when palette toggled
                    const sendBtnEl = document.getElementById('chat-send-btn');
                    if (sendBtnEl) sendBtnEl.addEventListener('click', hideMention);
                } catch (e) { /* ignore */ }
            });
        </script>

        <script>// Robust expand/collapse with smooth animation
        (function () {
            function animateMaxHeight(element, fromPx, toPx, duration = 300) {
                // Ensure we have integer values
                fromPx = Math.round(Number(fromPx) || 0);
                toPx = Math.round(Number(toPx) || 0);

                // Force the element to use explicit height during animation so
                // layout is updated reliably even with flex/overflow rules.
                element.style.overflow = 'hidden';
                element.style.maxHeight = fromPx + 'px';
                element.style.height = fromPx + 'px';

                // Force style recalculation
                element.offsetHeight;

                // Animate both max-height and height for better cross-browser results
                element.style.transition = `max-height ${duration}ms ease, height ${duration}ms ease`;

                function onend(e) {
                    if (e.propertyName !== 'height' && e.propertyName !== 'max-height') return;

                    element.style.transition = '';

                    // Keep a stable expanded/collapsed size after the animation.
                    // Using max-height alone can be masked by flex layout; explicit height
                    // guarantees the visible box size.
                    element.style.height = toPx + 'px';
                    element.style.maxHeight = toPx + 'px';

                    element.removeEventListener('transitionend', onend);
                }

                element.addEventListener('transitionend', onend);

                // Trigger target values on next frame
                requestAnimationFrame(() => {
                    element.style.maxHeight = toPx + 'px';
                    element.style.height = toPx + 'px';
                });
            }

            function setupExpandToggles() {
                // Initialize blocks that either:
                //  - have been opt-in marked with `.expandable`, OR
                //  - already contain an `.expand-toggle` button (existing behavior)
                const allBlocks = Array.from(document.querySelectorAll('.custom-block-badges'));
                const expandableBlocks = allBlocks.filter(b => b.classList.contains('expandable') || b.querySelector('.expand-toggle'));

                // mark them collapsible for styling fallbacks
                expandableBlocks.forEach(el => el.setAttribute('data-collapsible', 'true'));

                // For blocks explicitly opted-in via `.expandable`, ensure they have a toggle.
                expandableBlocks.forEach(block => {
                    if (block.classList.contains('expandable') && !block.querySelector('.expand-toggle')) {
                        const btn = document.createElement('button');
                        btn.className = 'expand-toggle';
                        btn.setAttribute('aria-label', 'Expand block');
                        btn.title = 'Expand';
                        btn.innerHTML = `
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                                <rect x="0" y="0" width="24" height="24" rx="4" fill="transparent" />
                                <path d="M6 18 L18 6" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M14 6 L18 6 L18 10" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M18 18 L6 6" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M6 14 L6 18 L10 18" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>`;
                        block.insertBefore(btn, block.firstChild);
                    }
                });

                // Prepare stored heights and attributes for each expandable block
                expandableBlocks.forEach(block => {
                    let origPx = 360;
                    if (block.dataset.originalHeight) {
                        origPx = parseInt(block.dataset.originalHeight, 10) || origPx;
                    } else if (block.dataset.collapsible === 'true') {
                        origPx = 360;
                    } else {
                        origPx = Math.ceil(block.scrollHeight);
                    }

                    block.dataset.originalHeight = String(origPx);
                    block.dataset.currentHeight = String(origPx);
                    block.style.maxHeight = origPx + 'px';

                    const existingBtn = block.querySelector('.expand-toggle');
                    if (existingBtn) {
                        existingBtn.setAttribute('aria-pressed', 'false');
                        existingBtn.dataset.expanded = 'false';
                    }
                });

                // Delegated click handler for all expand toggles. This ensures toggles
                // inserted dynamically or present initially will work, and prevents
                // duplicate/ordering issues with per-button initialization.
                if (!window.__expandDelegateBound) {
                    window.__expandDelegateBound = true;
                    document.addEventListener('click', function (e) {
                        const btn = e.target.closest && e.target.closest('.expand-toggle');
                        if (!btn) return;
                        const block = btn.closest('.custom-block-badges');
                        if (!block) return;

                        // debug
                        try { console.debug('[expand] toggle clicked', { block, btn }); } catch (err) {}

                        const orig = parseInt(block.dataset.originalHeight, 10) || 360;
                        const isExpanded = btn.dataset.expanded === 'true';
                        const currentVisible = Math.ceil(block.getBoundingClientRect().height) || orig;

                        if (!isExpanded) {
                            const doubleH = Math.max(orig * 2, block.scrollHeight, currentVisible + 1);
                            block.classList.add('expanded');
                            btn.dataset.expanded = 'true';
                            btn.setAttribute('aria-pressed', 'true');
                            animateMaxHeight(block, currentVisible, doubleH, 480);
                            block.dataset.currentHeight = String(doubleH);
                        } else {
                            block.classList.remove('expanded');
                            btn.dataset.expanded = 'false';
                            btn.setAttribute('aria-pressed', 'false');
                            animateMaxHeight(block, currentVisible, orig, 360);
                            block.dataset.currentHeight = String(orig);
                        }
                    }, false);
                }
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setupExpandToggles);
            } else {
                setupExpandToggles();
            }
        })();
        </script>
        
        <script> //searchbar index
            // Custom search redirect: map input keywords to pages; fallback to search-results.html?q=
            (function() {
                const map = {
                    'logout': 'index.html',
                    'home': 'index2.html',
                    'dash': 'index2.html',
                    'dashboard': 'index2.html',
                    'leaderboard': 'leaderboard.html',
                    'leader': 'leaderboard.html',
                    'premium': 'premium.html',
                    'profile': 'profile.html',
                    'quest': 'quests.html',
                    'quests': 'quests.html',
                    'community': 'community.html',
                    'settings': 'setting.html',
                    'setting': 'setting.html',
                    'help': 'help-center.html',
                    
                };

                function handleSearchSubmit(e, inputEl) {
                    e.preventDefault();
                    const raw = inputEl.value || '';
                    const term = raw.trim();
                    if (!term) return;
                    const lower = term.toLowerCase();

                    for (const key in map) {
                        if (Object.prototype.hasOwnProperty.call(map, key) && lower.includes(key)) {
                            // pass original query as q param
                            window.location.href = map[key] + '?q=' + encodeURIComponent(term);
                            return;
                        }
                    }

                    // no matching page -> go to generic search results page
                    window.location.href = 'search-results.html?q=' + encodeURIComponent(term);
                }

                const headerForm = document.getElementById('header-search-form');
                const headerInput = document.getElementById('search-input');
                if (headerForm && headerInput) {
                    headerForm.addEventListener('submit', (e) => handleSearchSubmit(e, headerInput));
                }

                const sidebarForm = document.getElementById('sidebar-search-form');
                const sidebarInput = document.getElementById('sidebar-search-input');
                if (sidebarForm && sidebarInput) {
                    sidebarForm.addEventListener('submit', (e) => handleSearchSubmit(e, sidebarInput));
                }

                // Optional: allow Enter inside inputs to submit (already handled by form submit)
                // Also optionally support pressing Enter without using the form:
                [headerInput, sidebarInput].forEach(inp => {
                    if (!inp) return;
                    inp.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            handleSearchSubmit(e, inp);
                        }
                    });
                });
            })();
        </script>
       
        <script> //dropdown profile update
            // Load updated profile from localStorage and display on the page.
            // This script only updates display elements; saving is handled by the settings page.
            (function () {
                const DISPLAY_NAME_ID = 'display-profile-name';
                const DISPLAY_EMAIL_ID = 'display-profile-email';
                const HEADER_NAME_ID = 'header-small-name';
                const HEADER_EMAIL_ID = 'header-small-email';

                function updateProfileDisplay() {
                    const name = localStorage.getItem('profileName') || '';
                    const email = localStorage.getItem('profileEmail') || '';

                    const displayName = document.getElementById(DISPLAY_NAME_ID);
                    const displayEmail = document.getElementById(DISPLAY_EMAIL_ID);
                    const headerName = document.getElementById(HEADER_NAME_ID);
                    const headerEmail = document.getElementById(HEADER_EMAIL_ID);

                    if (displayName) displayName.textContent = name || '—';
                    if (displayEmail) {
                        displayEmail.textContent = email || '—';
                        displayEmail.href = email ? ('mailto:' + email) : '#';
                    }
                    if (headerName) headerName.textContent = name || 'User';
                    if (headerEmail) {
                        headerEmail.textContent = email || '';
                        if (email) headerEmail.href = 'mailto:' + email;
                    }

                        // update header avatars (colored initials blocks)
                        const profileColor = localStorage.getItem('profileColor') || '#7C3AED';
                        const headerAvatar = document.getElementById('header-avatar');
                        const headerDropdownAvatar = document.getElementById('header-dropdown-avatar');
                        const initials = (name || '').split(' ').map(s => (s || '')[0] || '').join('').slice(0,2).toUpperCase() || 'U';
                        if (headerAvatar) {
                            headerAvatar.textContent = initials;
                            headerAvatar.style.backgroundColor = profileColor;
                            headerAvatar.style.color = '#ffffff';
                        }
                        if (headerDropdownAvatar) {
                            headerDropdownAvatar.textContent = initials;
                            headerDropdownAvatar.style.backgroundColor = profileColor;
                            headerDropdownAvatar.style.color = '#ffffff';
                        }

                    // update other common selectors (navbar username, profile-name, dropdown-username)
                    document.querySelectorAll('.navbar-username, #profile-name, #dropdown-username').forEach(el => {
                        if (el) el.textContent = name || '';
                    });
                }

                // update on initial load
                document.addEventListener('DOMContentLoaded', updateProfileDisplay);

                // update if localStorage changes in another tab/window
                window.addEventListener('storage', (e) => {
                    if (e.key === 'profileName' || e.key === 'profileEmail') updateProfileDisplay();
                });

                // Provide a global helper so settings page can call it after saving
                window.updateProfileDisplay = updateProfileDisplay;
            })();
        </script>

        <!--<script>
            // notification message list
            const tips = [
                '你是最最最棒的ദ്ദി˶ｰ̀֊ｰ́ )✧', 
                '我最最最最喜欢你 ˃̶͈ ꇴ ˂̶͈',
                '天冷了，多穿衣服', 
                '我想你了',
                '期待下一次见面',
                '多喝水哦~',
                '别熬夜(∗ᵒ̶̶̷̀ω˂̶́∗)੭₎₎̊₊♡',
                '早点休息',
                '好好爱自己',
                '今天过得开心嘛'
            ];

            // background color
            const bgColors = [
                'lightpink', 'skyblue', 'lightgreen', 'lavender',
                'lightyellow', 'plum', 'coral', 'bisque',
                'aquamarine', 'mistyrose', 'honeydew',
                'lavenderblush', 'oldlace'
            ];

            // create single window
            function createPopup() {
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                
                // popup animation
                const popup = document.createElement('div');
                popup.className = 'popup';
                
                // random scale
                const width = Math.floor(Math.random() * 100) + 200;
                const height = Math.floor(Math.random() * 30) + 50;
                
                // random position
                const x = Math.floor(Math.random() * (screenWidth - width));
                const y = Math.floor(Math.random() * (screenHeight - height));
                
                // style fomat
                popup.style.width = width + 'px';
                popup.style.height = height + 'px';
                popup.style.left = x + 'px';
                popup.style.top = y + 'px';
                popup.style.backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];
                popup.style.fontSize = (Math.floor(Math.random() * 4) + 12) + 'px';
                
                // random noification
                const tipText = tips[Math.floor(Math.random() * tips.length)];
                
                // add content
                popup.innerHTML = `
                    <div class="close-btn">×</div>
                    <div class="message">${tipText}</div>
                `;
                
                // add to page
                document.getElementById('popup-container').appendChild(popup);
                
                // close button
                const closeBtn = popup.querySelector('.close-btn');
                closeBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    popup.style.opacity = '0';
                    popup.style.transform = 'scale(0.8)';
                    setTimeout(() => popup.remove(), 300);
                });
                
                // close tab x 
                popup.addEventListener('click', function() {
                    this.style.opacity = '0';
                    this.style.transform = 'scale(0.8)';
                    setTimeout(() => this.remove(), 300);
                });
                
                return popup;
            }

            // build multiple windows
            function createMultiplePopups(count) {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        createPopup();
                    }, i * 50); // 50ms delay
                }
                
                // close all window after 10s
                setTimeout(() => {
                    /*const popups = document.querySelectorAll('.popup');
                    popups.forEach(popup => {
                        popup.style.opacity = '0';
                        popup.style.transform = 'scale(0.8)';
                        setTimeout(() => popup.remove(), 300);
                    });
                    
                    // noti box
                    const hint = document.createElement('div');
                    hint.innerHTML = '万事胜意<br>许你平安喜樂！';
                    hint.style.cssText = `
                        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                        text-align: center; font-size: 16px; z-index: 1001;
                    `;
                    document.body.appendChild(hint);*/
                    
                    setTimeout(() => hint.remove(), 5000);
                }, 10000);
            }

            // recreate windows
            window.addEventListener('load', () => {
                createMultiplePopups(20);
            });
        </script>-->

        <script> //community chat animation
            let amountOfColors = 18; // Or "participants"
            const AUTO_DELETE_MS = 10000; // milliseconds before a chat line auto-deletes
            const AUTO_DELETE_JITTER = 3000; // optional randomness added to auto-delete time
            const FADE_OUT_MS = 500; // fade out duration
            // Message limits: when total messages exceed MAX_TOTAL_MESSAGES,
            // remove older messages until only PRESERVE_LATEST remain.
            const MAX_TOTAL_MESSAGES = 20;
            const PRESERVE_LATEST = 5;

            let container = document.getElementById("chat-container");

            // Ensure visible scrollbar when chat is inside a `.custom-block-badges.scrollable`
            (function ensureChatScrollable(){
                try {
                    if (!container) return;
                    const parent = container.closest && container.closest('.custom-block-badges');
                    if (!parent || !parent.classList.contains('scrollable')) return;


                    // make the chat area scrollable and ensure visible scrollbar
                    container.style.overflowY = 'auto';
                    container.style.overflowX = 'hidden';
                    container.style.display = 'block';
                    container.style.position = 'relative';
                    container.style.boxSizing = 'border-box';
                    container.style.webkitOverflowScrolling = 'touch';
                    // ensure some right padding so a vertical scrollbar doesn't overlap content
                    if (!container.style.paddingRight) container.style.paddingRight = '8px';

                    // Compute a sensible max-height based on the parent block's current visible height.
                    function updateContainerMax() {
                        try {
                            // prefer clientHeight which excludes scrollbars
                            const parentH = parent.clientHeight || Math.ceil(parent.getBoundingClientRect().height || 0);
                            // estimate space used by header/title and controls inside the block
                            const titleEl = parent.querySelector('h5');
                            const controlsEl = parent.querySelector('.container-items');
                            const headerH = (titleEl && titleEl.offsetHeight) ? titleEl.offsetHeight : 28;
                            const controlsH = (controlsEl && controlsEl.offsetHeight) ? controlsEl.offsetHeight : 64;
                            const extra = 24; // breathing room
                            const h = Math.max(120, Math.floor(parentH - headerH - controlsH - extra));
                            container.style.maxHeight = h + 'px';
                        } catch (e) { /* ignore */ }
                    }

                    // initial sizing
                    updateContainerMax();

                    // pick a theme color for the scrollbar thumb
                    let thumbColor = (function(){
                        try {
                            // prefer explicit profile color if available
                            const p = localStorage.getItem('profileColor');
                            if (p) return p.trim();
                            // fallback: try to read a prominent header/avatar background
                            const avatar = document.getElementById('header-avatar') || parent.querySelector('.chat-name');
                            if (avatar) {
                                const cs = window.getComputedStyle(avatar);
                                if (cs && cs.backgroundColor && cs.backgroundColor !== 'transparent') return cs.backgroundColor;
                            }
                        } catch (e) { /* ignore */ }
                        return 'rgba(0,0,0,0.22)';
                    })();

                    // apply Firefox scrollbar styling
                    container.style.scrollbarWidth = 'thin';
                    container.style.scrollbarColor = thumbColor + ' transparent';

                    // Inject WebKit scrollbar styles (use the computed thumbColor). Replace any existing style with same id.
                    const STYLE_ID = 'chat-scrollbar-styles';
                    let existing = document.getElementById(STYLE_ID);
                    const safeColor = thumbColor.replace(/"/g,'\\"');
                    const css = `
.custom-block-badges.scrollable #chat-container{position:relative}
.custom-block-badges.scrollable #chat-container::-webkit-scrollbar{width:12px;height:12px}
.custom-block-badges.scrollable #chat-container::-webkit-scrollbar-thumb{background:${safeColor} !important;border-radius:8px;border:2px solid rgba(0,0,0,0.08) !important}
.custom-block-badges.scrollable #chat-container::-webkit-scrollbar-track{background:transparent}
`;
                    if (existing) {
                        existing.textContent = css;
                    } else {
                        const s = document.createElement('style');
                        s.id = STYLE_ID;
                        s.textContent = css;
                        document.head.appendChild(s);
                    }

                    // Observe parent attribute/style changes so we can update container max-height
                    const obs = new MutationObserver((muts) => {
                        updateContainerMax();
                    });
                    obs.observe(parent, { attributes: true, attributeFilter: ['style','class','data-original-height','data-current-height'] });

                    // also update on window resize and when layout stabilizes
                    const onResize = () => updateContainerMax();
                    window.addEventListener('resize', onResize, { passive: true });

                    // Call update after a short delay to handle initial layout/animations
                    setTimeout(updateContainerMax, 40);

                    // Keep a small reference on the parent so other scripts can disconnect if needed
                    parent.__chatScrollbarObserver = { obs, onResize };

                } catch (e) {
                    // fail silently if anything goes wrong
                }
            })();
            // Debug helper: enable by running `localStorage.setItem('chatDebug','1')` in console then reload.
            (function chatDebugHelper(){
                try {
                    if (localStorage.getItem('chatDebug') !== '1') return;
                    console.warn('CHAT DEBUG: forcing visible scrollbar and emitting diagnostics');
                    if (!container) { console.warn('CHAT DEBUG: #chat-container not found'); return; }
                    const parent = container.closest && container.closest('.custom-block-badges');
                    console.log('CHAT DEBUG: parent', parent);
                    // Force visible scroll behavior and a visible outline so you can see the box
                    container.style.overflowY = 'scroll';
                    container.style.paddingRight = '12px';
                    container.style.maxHeight = (parent ? (parent.clientHeight - 80) : 320) + 'px';
                    container.style.outline = '3px solid rgba(255,0,0,0.12)';
                    console.log('CHAT DEBUG: computed styles', getComputedStyle(container));
                    console.log('CHAT DEBUG: dims', {
                        clientHeight: container.clientHeight,
                        scrollHeight: container.scrollHeight,
                        parentClientHeight: parent ? parent.clientHeight : null
                    });
                    // Append a few test messages to force overflow
                    setTimeout(() => {
                        try { for (let i = 0; i < 12; i++) window.sendChatMessage && window.sendChatMessage('DEBUG message ' + (i+1)); } catch (e) { console.warn(e); }
                    }, 120);
                } catch (e) { /* ignore */ }
            })();
            let lineWidth = 400;
            let profileImgWidth = 60;
            let textWidth = lineWidth - 20 - profileImgWidth - 10;
            let chats = [];
            let maxTexts = 4;

            // Scroll helpers: keep the chat scrolled to bottom when the user
            // is already near the bottom, but allow manual scrolling to view history.
            function isUserNearBottom(el, threshold = 80) {
                if (!el) return true;
                try {
                    return (el.scrollHeight - el.scrollTop - el.clientHeight) <= threshold;
                } catch (e) { return true; }
            }

            function scrollChatToBottom() {
                if (!container) return;
                try { container.scrollTop = container.scrollHeight; } catch (e) {}
            }

            function scrollChatToBottomIfNeeded() {
                if (!container) return;
                if (isUserNearBottom(container, 120)) scrollChatToBottom();
            }

            // Enforce message retention policy:
            // - If total messages exceed `MAX_TOTAL_MESSAGES`, delete oldest
            //   messages until only `PRESERVE_LATEST` remain.
            // - This preserves the most recent `PRESERVE_LATEST` messages.
            function enforceMessageLimit(max = MAX_TOTAL_MESSAGES, preserve = PRESERVE_LATEST) {
                if (!container) return;
                try {
                    if (container.children.length <= max) return;
                    while (container.children.length > preserve) {
                        const oldest = container.firstElementChild;
                        if (!oldest) break;
                        // graceful fade then remove for a smoother UX
                        try {
                            oldest.classList.add('removing');
                            setTimeout(() => { try { oldest.remove(); } catch(e) {} }, FADE_OUT_MS);
                        } catch (e) {
                            try { oldest.remove(); } catch(e) {}
                        }
                    }
                } catch (e) { /* ignore */ }
            }

            function createElement(opts = {}) {
                let ele = document.createElement("div");
                if ("class" in opts) {
                    if (!Array.isArray(opts.class)) {
                        opts.class = [opts.class];
                    }
                    ele.classList.add(...opts.class);
                }
                return ele;
            }

            function addChat() {
                let chat = new Chat();
                chats.push(chat);
                // Do not start automatic looping here. Bots created with createBot()
                // will drive random/chat activity. This prevents non-bot automatic messages.
                // setTimeout(() => chat.loop(), 200);
                return chat;
            }

            class Chat {
                constructor() {
                    this.ele = createElement({ class: "chat" });
                    this.lines = [];
                    this.anim = null;
                    container.appendChild(this.ele);
                }
                addLine() {
                    let l = new Line(this); // pass parent chat reference
                    this.lines.push(l);
                    this.ele.appendChild(l.ele.lineContainer);
                    return l;
                }
                removeOldest() {
                    let maxCount = Math.ceil((window.innerHeight / 1080) * 12);
                    if (this.lines.length > maxCount) {
                        let oldest = this.lines.splice(0, this.lines.length - maxCount);
                        oldest.forEach((n) => this.ele.removeChild(n.ele.lineContainer));
                    }
                }
                loop() {
                    if (this.anim) {
                        this.stopLoop();
                    }
                    this.addLine();
                    this.removeOldest();
                    /*this.anim = setTimeout(() => this.loop(), Math.random() * 1300 + 180);*/
                    this.anim = setTimeout(() => this.loop(), 3000);
                }
                stopLoop() {
                    clearTimeout(this.anim);
                    this.anim = null;
                }
            }

            class Line {
                constructor(parentChat, opts = {}) {
                    this.parentChat = parentChat || null;

                    // allow overriding color/name/texts for user-submitted messages
                    if (opts.hue !== undefined) {
                        this.hue = opts.hue;
                        this.color = opts.color || `hsl(${this.hue}, 90%, 50%)`;
                        this.profileImgColor = opts.profileImgColor || `hsl(${this.hue}, 40%, 55%)`;
                    } else {
                        this.pickColor();
                    }

                    // If a specific profile image color was provided (e.g. for bots), prefer it
                    if (opts.profileImgColor !== undefined && opts.profileImgColor !== null) {
                        this.profileImgColor = opts.profileImgColor;
                    }

                    if (opts.name) {
                        this.name = opts.name;
                    } else {
                        this.pickName();
                    }

                    if (opts.textsArray) {
                        this.textsArray = Array.isArray(opts.textsArray) ? opts.textsArray : [String(opts.textsArray)];
                        this.textCount = this.textsArray.length;
                    } else {
                        this.pickText();
                    }

                    /*this.pickHasImg();
                    this.pickHasRichBody();*/
                    // preserve bot flag when provided
                    this.isBot = !!opts.isBot;
                    // preserve user flag and profile image/color when provided
                    this.isUser = !!opts.isUser;
                    this.profileImage = opts.profileImage || null;
                    this.setupElements();
                    this.animateIn();
                }

                pickColor() {
                    this.hue =
                        Math.floor(Math.random() * amountOfColors) * (360 / amountOfColors);
                    this.color = `hsl(${this.hue}, 90%, 50%)`;
                    this.profileImgColor = `hsl(${this.hue}, 40%, 55%)`;
                    return this.hue;
                }

                pickName() {
                    // pick a random human-like name
                    const NAMES = [
                        'Ava','Liam','Noah','Emma','Olivia','Mason','Sophia','Isabella','Lucas','Mia',
                        'Ethan','Amelia','Harper','Ella','James','Evelyn','Benjamin','Charlotte','Logan','Aria'
                    ];
                    this.name = NAMES[Math.floor(Math.random() * NAMES.length)];
                }

                pickText() {
                    // generate 1-4 short random sentences
                    const PHRASES = [
                        'Sounds good to me.',
                        'I will check and update.',
                        'Where can I find that?',
                        'Nice work! 🎉',
                        'Can we push this to production?',
                        'I like the new layout.',
                        'Let me know your thoughts.',
                        'That issue is resolved now.',
                        'I will follow up tomorrow.',
                        'Thanks for the update.'
                    ];
                    const count = 1 + Math.floor(Math.random() * 4);
                    this.textsArray = [];
                    for (let i = 0; i < count; i++) {
                        // choose a phrase and sometimes append a short extra
                        let phrase = PHRASES[Math.floor(Math.random() * PHRASES.length)];
                        if (Math.random() > 0.7) phrase += ' ' + (PHRASES[Math.floor(Math.random() * PHRASES.length)]).toLowerCase();
                        this.textsArray.push(phrase);
                    }
                    this.textCount = this.textsArray.length;
                }

                pickHasImg() {
                    this.hasImg = Math.random() > 0.9;
                }

                pickHasRichBody() {
                    // Use the real `hasImg` flag (typo previously used `hasImage`).
                    // Only allow a rich body when there is NOT an image and with low probability.
                    this.hasRichBody = !this.hasImg && Math.random() > 0.85;
                }

                setupElements() {
                    let ele = this.createElement();
                    this.ele = ele;
                    // set name text and profile initials
                    ele.name.textContent = this.name;
                    // fill texts — convert @mentions into a pill + color block when possible
                    function escapeHtml(str) {
                        return (str + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    }

                    function renderTextWithMentions(src) {
                        const raw = src == null ? '' : String(src);
                        // escape whole string first
                        const escaped = escapeHtml(raw);
                        // replace @name tokens with a structured mention element when the bot exists
                        return escaped.replace(/@([A-Za-z0-9_\-]+)/g, (m, token) => {
                            const registry = window.BOT_REGISTRY || {};
                            let matched = null;
                            for (const k in registry) {
                                if (Object.prototype.hasOwnProperty.call(registry, k) && k.toLowerCase() === token.toLowerCase()) {
                                    matched = k;
                                    break;
                                }
                            }
                            if (matched) {
                                const col = registry[matched] || '#999';
                                // expose the color as a CSS variable so the pill can use it as a background
                                return `<span class="mention" data-mention="${matched}" style="--mention-color: ${col}"><span class="mention-pill">@${matched}</span></span>`;
                            }
                            return `<span class="mention"><span class="mention-pill">@${escapeHtml(token)}</span></span>`;
                        });
                    }

                    ele.texts.forEach((n, i) => {
                        // Prefer the per-element raw text produced during createElement (wrapped chunks).
                        const txt = (n && n.dataset && n.dataset.raw) ? n.dataset.raw : (this.textsArray[i] || '');
                        try {
                            // If there is no non-whitespace content, remove the empty text element
                            if (!String(txt).trim()) {
                                if (n && n.parentNode) n.parentNode.removeChild(n);
                                return;
                            }

                            n.innerHTML = renderTextWithMentions(txt);
                            // render as full-width block; sizing handled by CSS
                            try {
                                n.style.display = 'block';
                                n.style.width = '100%';
                                n.style.maxWidth = '100%';
                                n.style.boxSizing = 'border-box';
                                n.style.overflowWrap = 'break-word';
                            } catch (e) { /* ignore */ }
                        } catch (e) {
                            n.textContent = txt;
                        }
                    });
                    // style name and profile
                    ele.name.style.backgroundColor = 'transparent';
                    ele.name.style.height = 'auto';
                    // compute initials (up to 2 characters)
                    const initials = (this.name || '').split(' ').map(s => (s || '')[0] || '').join('').slice(0,2).toUpperCase() || 'U';

                    // If this line represents a user (not a bot) and the user has a saved profile image/color,
                    // prefer rendering that. Bots continue to use their provided profileImgColor.
                    if (!this.isBot && this.isUser) {
                        // prefer provided profileImage, then localStorage.profileImage, else use color
                        const savedImage = this.profileImage || localStorage.getItem('profileImage');
                        const savedColor = this.profileImgColor || localStorage.getItem('profileColor') || this.profileImgColor;
                        if (savedImage) {
                            ele.profileImg.style.backgroundImage = `url(${savedImage})`;
                            ele.profileImg.textContent = '';
                        } else {
                            ele.profileImg.style.backgroundColor = savedColor;
                            ele.profileImg.textContent = initials;
                        }
                    } else {
                        ele.profileImg.style.backgroundColor = this.profileImgColor;
                        ele.profileImg.textContent = initials;
                    }

                    // If this line represents a bot, render a rounded-square avatar with initials
                    if (this.isBot) {
                        ele.profileImg.style.color = '#ffffff';
                        ele.profileImg.style.display = 'flex';
                        ele.profileImg.style.alignItems = 'center';
                        ele.profileImg.style.justifyContent = 'center';
                        ele.profileImg.style.fontWeight = '700';
                        ele.profileImg.style.fontSize = '18px';
                        ele.profileImg.style.width = '48px';
                        ele.profileImg.style.height = '48px';
                        ele.profileImg.style.borderRadius = '8px';
                        ele.profileImg.style.flex = '0 0 48px';
                        ele.profileImg.setAttribute('role','img');
                        ele.profileImg.setAttribute('aria-label', `Profile picture for ${this.name}, color ${this.profileImgColor || ''}`);
                    } else {
                        // Non-bot / user: use the same rounded-square avatar style as bots
                        ele.profileImg.style.color = '#ffffff';
                        ele.profileImg.style.display = 'flex';
                        ele.profileImg.style.alignItems = 'center';
                        ele.profileImg.style.justifyContent = 'center';
                        ele.profileImg.style.fontWeight = '700';
                        ele.profileImg.style.fontSize = '18px';
                        ele.profileImg.style.width = '48px';
                        ele.profileImg.style.height = '48px';
                        ele.profileImg.style.borderRadius = '8px';
                        ele.profileImg.style.flex = '0 0 48px';
                        ele.profileImg.setAttribute('role','img');
                        ele.profileImg.setAttribute('aria-label', `Profile picture for ${this.name}, color ${this.profileImgColor || ''}`);
                    }
                }

                animateIn() {
                    let delay = 35; // Some times it won't animate correctly without this
                    let ele = this.ele;
                    setTimeout(() => {
                        ele.lineContainer.style.opacity = 1;
                        ele.lineContainer.style.maxHeight = "200px";
                        ele.lineContainer.style.transform = "translateX(0px) scale(1)";
                    }, delay);

                    let otherEleList = [ele.profileImg, ele.name, ...ele.texts];

                    if ("img" in ele) {
                        otherEleList.push(ele.img);
                    } else if ("richBody" in ele) {
                        otherEleList.push(ele.richBody);
                    }

                    delay += 40;

                    otherEleList.forEach((e, i) => {
                        setTimeout(() => {
                            e.style.opacity = 1;
                            e.style.transform = "translateY(0px)";
                        }, (delay += 50));
                    });

                    ele.texts.forEach((n, i, arr) =>
                        setTimeout(() => (n.style.opacity = 1), 70 * (i + 3) + delay)
                    );
                    // schedule auto-delete only when AUTO_DELETE_MS > 0
                    if (typeof AUTO_DELETE_MS === 'number' && AUTO_DELETE_MS > 0) {
                        const ttl = AUTO_DELETE_MS + Math.floor(Math.random() * AUTO_DELETE_JITTER);
                        this._autoDeleteTimeout = setTimeout(() => this.animateOutAndRemove(), ttl);
                    } else {
                        this._autoDeleteTimeout = null;
                    }
                }

                animateOutAndRemove() {
                    // fade out visuals, then remove from DOM and parent lines array
                    if (!this.ele || !this.ele.lineContainer) return;
                    // clear any pending auto-delete to avoid double calls
                    if (this._autoDeleteTimeout) {
                        clearTimeout(this._autoDeleteTimeout);
                        this._autoDeleteTimeout = null;
                    }
                    // start fade out
                    this.ele.lineContainer.style.transition = `opacity ${FADE_OUT_MS}ms ease, max-height ${FADE_OUT_MS}ms ease, transform ${FADE_OUT_MS}ms ease`;
                    this.ele.lineContainer.style.opacity = 0;
                    this.ele.lineContainer.style.maxHeight = "0px";
                    this.ele.lineContainer.style.transform = "translateX(-10px) scale(.98)";
                    // remove child elements after fade
                    setTimeout(() => {
                        try {
                            if (this.ele && this.ele.lineContainer && this.ele.lineContainer.parentNode) {
                                this.ele.lineContainer.parentNode.removeChild(this.ele.lineContainer);
                            }
                            // remove from parentChat.lines array if possible
                            if (this.parentChat && Array.isArray(this.parentChat.lines)) {
                                const idx = this.parentChat.lines.indexOf(this);
                                if (idx > -1) this.parentChat.lines.splice(idx, 1);
                            }
                        } catch (e) { /* ignore */ }
                    }, FADE_OUT_MS + 10);
                }

                createElement() {
                    let lineContainer = createElement({ class: "line-container" });
                    let line = createElement({ class: "line" });
                    let profileImg = createElement({ class: "profile-img" });
                    let body = createElement({ class: "body" });
                    let name = createElement({ class: "chat-name" });
                    let texts = [];
                    let img = createElement({ class: "img" });
                    let richBody = createElement({ class: "rich-body" });
                    body.appendChild(name);
                    // Create `.text` elements by wrapping each message string into line-sized blocks.
                    // This determines how many visual line blocks appear for each message based on length.
                    function wrapToLines(str) {
                        const raw = String(str == null ? '' : str).trim();
                        if (!raw) return [];
                        // approximate chars per line based on available textWidth
                        const approxChar = 8; // px per character (approx)
                        const padding = 24; // account for bubble padding
                        const availablePx = (typeof textWidth === 'number' && textWidth > 0) ? textWidth : 320;
                        const maxChars = Math.max(24, Math.floor((availablePx - padding) / approxChar));
                        const words = raw.split(/\s+/);
                        const lines = [];
                        let cur = '';
                        words.forEach((w) => {
                            if (!cur) {
                                cur = w;
                                return;
                            }
                            if ((cur.length + 1 + w.length) <= maxChars) {
                                cur += ' ' + w;
                            } else {
                                lines.push(cur);
                                cur = w;
                            }
                        });
                        if (cur) lines.push(cur);
                        return lines;
                    }

                    if (Array.isArray(this.textsArray) && this.textsArray.length) {
                        for (let i = 0; i < this.textsArray.length; i++) {
                            const candidate = this.textsArray[i];
                            // wrap into one or more visual lines
                            const chunks = wrapToLines(candidate);
                            for (const ch of chunks) {
                                let text = createElement({ class: "text" });
                                // store the actual line text on the element so setupElements can render it
                                try { text.dataset.raw = ch; } catch (e) { /* ignore */ }
                                texts.push(text);
                                body.appendChild(text);
                            }
                        }
                        // If nothing was added (all entries were empty), still create one text node
                        if (texts.length === 0) {
                            let text = createElement({ class: "text" });
                            texts.push(text);
                            body.appendChild(text);
                        }
                    } else {
                        for (let i = 0; i < (this.textCount || 1); i++) {
                            let text = createElement({ class: "text" });
                            texts.push(text);
                            body.appendChild(text);
                        }
                    }
                    line.appendChild(profileImg);
                    line.appendChild(body);
                    lineContainer.appendChild(line);
                    let out = { lineContainer, line, profileImg, body, name, texts };
                    this.hasImg && (out.img = img) && body.appendChild(img);
                    this.hasRichBody && (out.richBody = richBody) && body.appendChild(richBody);
                    return out;
                }
            }

            function loop() {
                chats.forEach((n) => n.loop());
            }

            function stopLoop() {
                chats.forEach((n) => n.stopLoop());
            }

            (() => addChat())();

            // Helper to send a custom message into the chat animation.
            window.sendChatMessage = function (text, opts = {}) {
                if (!text) return null;
                const chat = chats[0] || addChat();

                // Determine the sender name: prefer opts, then localStorage profileName, then #profile-name text, then 'You'
                let username = opts.name || localStorage.getItem('profileName') || null;
                if (!username) {
                    const profileEl = document.getElementById('profile-name');
                    if (profileEl && profileEl.textContent && profileEl.textContent.trim()) username = profileEl.textContent.trim();
                }
                if (!username) username = 'You';

                // Give user's messages a consistent hue (purple) unless overridden
                const userHue = opts.hue !== undefined ? opts.hue : 270;

                // include user flags and saved profile info so chat avatar matches header/profile
                const savedProfileColor = localStorage.getItem('profileColor') || undefined;
                const savedProfileImage = localStorage.getItem('profileImage') || undefined;
                const lineOpts = Object.assign({ textsArray: [text], name: username, hue: userHue, isUser: true, profileImgColor: savedProfileColor, profileImage: savedProfileImage }, opts);
                const line = new Line(chat, lineOpts);
                // register and append
                chat.lines.push(line);
                try { chat.ele.appendChild(line.ele.lineContainer); } catch (e) { /* ignore */ }
                // user sent a message -> clear unread notifications (centralized)
                try { if (typeof setUnreadCount === 'function') setUnreadCount(0); else localStorage.setItem('chatUnreadCount', '0'); } catch(e) {}
                // enforce max messages and keep view scrolled if appropriate
                try { enforceMessageLimit(); } catch(e) {}
                try { scrollChatToBottomIfNeeded(); } catch(e) {}
                return line;
            };

            // Create a dummy bot that periodically posts messages using the Line class.
            // Usage: const b = createBot('Aria', { profileImgColor:'#6ee7b7', messages:['Hi','How are you?'], interval:5000 });
            // Notification helpers: increment unread count and show/hide header dot
            function getUnreadCount() {
                return parseInt(localStorage.getItem('chatUnreadCount') || '0', 10) || 0;
            }

            function setUnreadCount(n) {
                try { localStorage.setItem('chatUnreadCount', String(n)); } catch(e) {}
                // show notification on the bell dropdown trigger instead of the avatar
                const bellTrigger = document.getElementById('navbarLightDropdownMenuLink');
                if (bellTrigger) {
                    const count = Math.max(0, parseInt(n, 10) || 0);
                    if (count > 0) {
                        bellTrigger.classList.add('notification-dot');
                    } else {
                        bellTrigger.classList.remove('notification-dot');
                    }

                    // Update unread badge text (1–2 digits, capped)
                    const badge = bellTrigger.querySelector && bellTrigger.querySelector('.bell-dot');
                    if (badge) {
                        const text = count > 99 ? '99+' : String(count);
                        badge.textContent = count > 0 ? text : '';
                        // toggle single-digit class for perfect circle
                        if (count > 0 && count < 10) badge.classList.add('single'); else badge.classList.remove('single');
                        badge.setAttribute('aria-label', count > 0 ? `${text} unread notifications` : 'No unread notifications');
                        if (count === 0) badge.setAttribute('aria-hidden', 'true'); else badge.removeAttribute('aria-hidden');
                    }
                }
                // Do NOT add notification-dot to header avatars here — keep notifications
                // targeted to the bell trigger only. This avoids duplicate/overlapping
                // indicators on the UI.
            }

            function incrementUnread() {
                const next = getUnreadCount() + 1;
                setUnreadCount(next);
            }

            // Initialize dot on page load from stored value
            try { setUnreadCount(getUnreadCount()); } catch(e) {}

            // Clear unread count when the user clicks the bell (or opens the dropdown).
            // This ensures unread is acknowledged when the user inspects notifications.
            try {
                document.addEventListener('DOMContentLoaded', () => {
                    const bell = document.getElementById('navbarLightDropdownMenuLink');
                    if (!bell) return;

                    // Primary: clear when the bell is clicked
                    bell.addEventListener('click', (e) => {
                        try { setUnreadCount(0); } catch (err) { /* ignore */ }
                    });

                    // Secondary: if Bootstrap emits dropdown events, clear when shown as well
                    try {
                        bell.addEventListener('shown.bs.dropdown', () => { try { setUnreadCount(0); } catch (err) {} });
                    } catch (err) { /* not fatal if event not supported */ }
                });
            } catch (e) { /* ignore global attach errors */ }

            window.createBot = function (name, opts = {}) {
                const chat = chats[0] || addChat();
                const messages = opts.messages || ["Hello!", "Nice to meet you."];
                const interval = typeof opts.interval === 'number' ? opts.interval : 8000;
                // prefer explicit opts.profileImgColor, then registered bot color, then opts.color
                const profileImgColor = opts.profileImgColor || (window.BOT_REGISTRY && window.BOT_REGISTRY[name]) || opts.color || undefined;
                const hue = opts.hue !== undefined ? opts.hue : undefined;

                let i = 0;
                const timer = setInterval(() => {
                    const text = messages[i % messages.length];
                    const lineOpts = { name: name, textsArray: [text], isUser: false, isBot: true };
                    if (profileImgColor) lineOpts.profileImgColor = profileImgColor;
                    if (hue !== undefined) lineOpts.hue = hue;
                    const line = new Line(chat, lineOpts);
                    chat.lines.push(line);
                    try { chat.ele.appendChild(line.ele.lineContainer); } catch (e) {}
                    // enforce max messages and keep view scrolled if appropriate
                    try { enforceMessageLimit(); } catch(e) {}
                    try { scrollChatToBottomIfNeeded(); } catch(e) {}
                    // New bot message -> increment unread count and show notification
                    try { incrementUnread(); } catch (e) { console.error('Failed to update unread count', e); }
                    i++;
                }, interval);

                const bot = {
                    name,
                    color: profileImgColor,
                    stop() { clearInterval(timer); },
                    start() { /* no-op: already running */ },
                    timer
                };
                // register bot instance for external control
                window._bots = window._bots || [];
                window._bots.push(bot);
                return bot;
            };

            // Spawn a few sample bots (no-op if you prefer to create them manually)
            window.spawnSampleBots = function () {
                if (window._sampleBotsSpawned) return;
                window._sampleBotsSpawned = true;
                const bots = [];
                bots.push(window.createBot('Aria', { profileImgColor: '#6EE7B7', messages: ['Nice work! 🎉','Thanks for the update.'], interval: 9000 }));
                bots.push(window.createBot('James', { profileImgColor: '#7C3AED', messages: ['Where can I find that?','Sounds good to me.'], interval: 7000 }));
                bots.push(window.createBot('Ava', { profileImgColor: '#F97316', messages: ['I will check and update.','Let me know your thoughts.'], interval: 11000 }));
                return bots;
            };

            // Wire the input controls to the send helper
            document.addEventListener('DOMContentLoaded', () => {
                const input = document.getElementById('chat-input-field');
                const sendBtn = document.getElementById('chat-send-btn');
                const addFileBtn = document.getElementById('chat-add-file');

                if (input) {
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            const val = input.value.trim();
                            if (!val) return;
                            window.sendChatMessage(val);
                            input.value = '';
                        }
                    });
                }

                if (sendBtn && input) {
                    sendBtn.addEventListener('click', () => {
                        const val = input.value.trim();
                        if (!val) return;
                        window.sendChatMessage(val);
                        input.value = '';
                        input.focus();
                    });
                }

                // bot palette container (initially hidden; clicking add-file toggles it)
                const botPalette = document.querySelector('.container-items');
                if (botPalette) {
                    botPalette.hidden = true;
                }

                if (addFileBtn) {
                    // Toggle the bot palette when clicking the attach button.
                    addFileBtn.setAttribute('aria-pressed', 'false');
                    addFileBtn.addEventListener('click', (e) => {
                        if (botPalette) {
                            const isHidden = !!botPalette.hidden;
                            botPalette.hidden = !isHidden;
                            addFileBtn.setAttribute('aria-pressed', String(!isHidden));
                            // prevent focusing the input when toggling
                            return;
                        }
                        if (input) input.focus();
                    });
                }

                // Color palette buttons: set the local profile color or create a bot when modifier key pressed
                const colorButtons = document.querySelectorAll('.item-color');
                if (colorButtons && colorButtons.length) {
                    const NAMES = [
                        'Ava','Liam','Noah','Emma','Olivia','Mason','Sophia','Isabella','Lucas','Mia',
                        'Ethan','Amelia','Harper','Ella','James','Evelyn','Benjamin','Charlotte','Logan','Aria'
                    ];
                    const stored = (localStorage.getItem('profileColor') || '').toLowerCase();
                    colorButtons.forEach((btn, idx) => {
                        // Read color from inline CSS variable `--color` if present, then from data-color,
                        // then fallback to legacy aria-color (was previously holding the name),
                        // finally fall back to computed background color.
                        let col = '';
                        try {
                            col = btn.style && btn.style.getPropertyValue('--color') ? btn.style.getPropertyValue('--color').trim() : '';
                        } catch (e) { col = ''; }
                        if (!col) col = (btn.dataset && btn.dataset.color) ? (btn.dataset.color + '').trim() : '';
                        if (!col) col = (btn.getAttribute('aria-color') || '').trim();
                        if (!col) {
                            const cs = window.getComputedStyle ? getComputedStyle(btn) : null;
                            col = (cs && (cs.backgroundColor || cs.color)) ? (cs.backgroundColor || cs.color) : '';
                        }
                        const botName = btn.dataset && btn.dataset.botName ? btn.dataset.botName : (NAMES[idx] || `Bot${idx+1}`);
                        // compute initials (1-2 chars) and render on the swatch
                        const initials = (botName || '').split(' ').map(s => s[0] || '').join('').slice(0,2).toUpperCase();
                        try { btn.textContent = initials; } catch (e) { /* ignore */ }
                        btn.setAttribute('data-initial', initials);
                        btn.setAttribute('role', 'button');
                        btn.setAttribute('tabindex', '0');
                        btn.setAttribute('aria-label', `Bot ${botName}, color ${col}`);
                        btn.setAttribute('aria-pressed', (stored && stored.toLowerCase() === (col + '').toLowerCase()) ? 'true' : 'false');

                        // register the button's name->color mapping globally so createBot can reuse it
                        window.BOT_REGISTRY = window.BOT_REGISTRY || {};
                        window.BOT_REGISTRY[botName] = col;

                        // clicking spawns the bot; modifier-click (ctrl/meta/shift) sets profile color instead
                        btn.addEventListener('click', (e) => {
                            if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                // set profile color
                                localStorage.setItem('profileColor', col);
                                colorButtons.forEach((b) => b.setAttribute('aria-pressed', 'false'));
                                btn.setAttribute('aria-pressed', 'true');
                                try { console.info('Profile color set to', col); } catch (err) {}
                                return;
                            }

                            // spawn bot with this name and color
                            if (window.createBot) {
                                const bot = window.createBot(botName, { profileImgColor: col, messages: [
                                    'Hello!', 'How is everyone?', 'Nice work!', 'I will check and update.'
                                ], interval: 6000 + (idx * 500) });
                                try { console.info('Created bot', bot && bot.name); } catch (err) {}
                            }
                        });

                        btn.addEventListener('keydown', (e) => {
                            // Enter/Space -> spawn bot
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                if (e.shiftKey) {
                                    // Shift+Enter: set profile color
                                    localStorage.setItem('profileColor', col);
                                    colorButtons.forEach((b) => b.setAttribute('aria-pressed', 'false'));
                                    btn.setAttribute('aria-pressed', 'true');
                                } else {
                                    // spawn bot
                                    if (window.createBot) window.createBot(botName, { profileImgColor: col, messages:['Hi'], interval:7000 });
                                }
                            }
                        });
                    });
                }
            });

        </script>

    </body>
</html>